# 🗓️ 進度更新｜2025‑08‑09

## ✅ 完成/決策
- **Component 架構收斂**
  - 採用 `Component` 基類封裝共用行為：`Add / Cut / Use / Clear`。
  - 特例行為由子類 **選擇性 override**（目前 Charge 不需額外 override）。
  - 降低耦合，刪除過度設計，數值邏輯回到資料物件本身。

- **ActorOp 定位明確**
  - 僅作為 **AtomicCommand 的統一入口**，不再承擔業務邏輯。
  - 呼叫路徑統一：`AtomicCommand → ActorOp.* → Component.*`。
  - 保留可讀式 API：`ActorOp.Add<Charge>(actor, 1)`。

- **從 enum+array 轉為泛型直掛**
  - 移除 `_components[]` 與 `ComponentType` 依賴。
  - Actor 直掛必要欄位（`HP`, `Shield`）＋可選欄位（`Charge`, `AP?`）。
  - 泛型存取：`actor.Get<T>()`、`ActorOp.Add<T>(actor, x)`，降低轉型與維護成本。

- **AP Component 設計**
  - 新增 `AP`：`Max` 不當上限，改用 `PerTurn`（每回合預設補滿值）。
  - API：`AP.RefillAtTurnStart()` 將 `Value` 重置為 `PerTurn`。
  - `Use()` 沿用基類，不需 override；`Add()` 取消上限檢查（AP 無上限）。

- **UI 更新策略**
  - 確認 UI 未更新主因：無法判斷局部刷新。
  - 暫採 **全域刷新事件**：`ActorOp` 操作後觸發 `UISignalHub.NotifyUIRefresh()`，UI 統一重抓最新狀態。
  - 優先保正確性，效能後續再細化事件。

## 🧩 修正/排除
- `CS0119`：`UISignalHub.NotifyAPChanged(int)` 是方法非委派，導致 `?.Invoke` 報錯。
  - 方案：
    - A) 改為 `Action<int>`，與其他通知一致（推薦）。
    - B) 保持方法，在 `ActorOp` 以 lambda 包裝呼叫。

## 🚧 仍在處理 / 風險
- **Turn Manager 串接**：回合開始需統一呼叫 `ActorOp.RefillAPAtTurnStart(actor)`。
- **UI 訂閱**：全域刷新事件尚未全面接上（玩家區塊、敵人區塊、手牌/資源列）。
- **舊檔清理**：移除早期 `ActorOp`（ref int/array 版本）與重複檔案。
- **訊號命名一致性**：四種資源通知與全域刷新事件型別需統一。

## ▶️ 推進計畫
1. **訊號統一**
   - [ ] 將四個資源變更通知統一為 `Action<int>`。
   - [ ] 新增 `Action NotifyUIRefresh`，並在 `ActorOp` 每次操作後觸發。
2. **AP 整合**
   - [ ] `Actor` 建構時支援 `apPerTurn`。
   - [ ] `TurnManager` 在 `TurnStart` 呼叫 `ActorOp.RefillAPAtTurnStart()`。
3. **UI 接線**
   - [ ] UI 訂閱 `NotifyUIRefresh` → `KernelConnector.GetUIState()` → `UpdateAllUI(state)`。
   - [ ] 保留局部通知以利除錯。
4. **遺留清理**
   - [ ] 刪除舊版 `ActorOp` 與 `ComponentType` 陣列依賴。
   - [ ] 檢查 namespace 一致性。

## 📌 備忘 / 設計準則更新
- 優先保證 **資料 → 入口 → 事件 → UI 刷新** 的單一通路。
- 基類 `Component` 收斂通用數值行為；子類僅在必要時 override。
- 泛型 API 固化：`ActorOp.Add<T>/Cut<T>/Use<T>/Clear<T>`，`Actor.Get<T>()`。
