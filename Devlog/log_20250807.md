# 📦 Recall V0.4 - 第一階段完成總結（2025-08-06）

## 📁 專案初始化
- ✅ 成功建立 `Godot 4.4.1 + Mono` C# 專案
- ✅ 確立主結構目錄與 `Script/` 資料夾命名規範
- ✅ Combat 模組採用 `Control` 作為主入口
- ✅ 所有 `.csproj`, `.godot` 組態無誤，成功執行

---

## 🧱 核心模組完成

### 🔷 `CombatState.cs`
- 繼承自 Godot `Node`，為戰鬥狀態容器
- 持有 `PhaseContext` 代表目前 phase 狀態
- 實作 `_Ready()` 完成初始化

### 🔷 `PhaseContext.cs`
- 定義 `PhaseStep` 枚舉 + `TurnNum`
- 為 struct 型別，支援 `ref` 傳遞
- 可安全被核心 kernel 推進與讀寫

### 🔷 `PhaseStep.cs`
- 定義完整階段枚舉：
  - `TurnStart`, `EnemyInit`, `EnemyIntent`, ...
  - `PlayerInput`, `PlayerExecute`, `TurnEnd`, `CombatEnd`

---

## ⚙️ 核心邏輯：`CombatKernel.cs`
- `Run(ref PhaseContext)`：單步推進 phase
- `AdvanceUntilInput(ref ...)`：連續推進至需要輸入
- 同時支援 `ref CombatState` / `ref PhaseContext` 呼叫
- 加入 debug log 輸出（`GD.Print()`）

---

## 🔄 Phase 驅動架構

### ✅ `PhaseMap.cs`
- 使用 Dictionary 對應 `PhaseStep` → 對應的 StepFunc

### ✅ `EnemyPhase.cs` / `PlayerPhase.cs`
- 定義每個 PhaseStep 的執行邏輯
- 將控制流清楚切分為敵我兩方

### ✅ `PhaseResult.cs`
- 枚舉型態，定義步驟結果狀態：
  - `Continue`
  - `WaitInput`
  - `Pending`
  - `Interrupt`

---

## 🔌 Godot 整合：`Combat.cs`
- 繼承 `Control`，作為主控制入口
- `[Export] public CombatState CombatState;` 成功連結 Node
- `Ready()` 中呼叫 `AdvanceUntilInput(ref CombatState.PhaseCtx)`
- 成功執行並停在 `WaitInput`

---

## ✅ 測試流程 Log

```text
Combat is ready
read CombatState success
Continue to next step EnemyInit
Continue to next step EnemyIntent
Continue to next step EnemyExecInstant
Continue to next step PlayerInit
Continue to next step PlayerDraw
Continue to next step PlayerInput
Wait Input
Combat state is ready
