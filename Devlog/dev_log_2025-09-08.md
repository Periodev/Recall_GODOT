# 🛠️ Dev Log — 2025-09-08

> 主題：Echo「查表化」落地、EchoStore 內配號、Recall 流程簡化為 `RecipeId` 單一來源。  
> 狀態：已合併、跑通。Godot 4.4.1 實測通過。

---

## ✅ 今日完成

### 1) Echo 建構改為「純查表」
- 新增/整併：`EchoFactory.BuildFromRecipe(int recipeId)`（Echo 初始 `Id=0` 占位）。
- Echo 內含**執行欄位**（`Op/TargetType/CostAP`）與**展示欄位**（`Name/Label/Summary`），UI 免再查表。
- 移除 `turn/runSeed` 參數依賴；建構完全由 `RecipeRegistry` 決定。  
**檔案**：`Core/Recall/EchoFactory.cs`、`Core/Recall/Echo.cs`

### 2) EchoStore 內配號（遞增、不回收）
- `TryAdd(Echo e)`：若 `e.Id == 0` → 指派 `_nextId++`；若外部帶入非零且撞號 → 迴避重配。  
- `TryRemove(Echo)`：以 **Id** 比對移除，避免槽位漂移造成刪錯。  
- 目的：場內唯一、與 UI 動畫安全對位、減少呼叫端參數。  
**檔案**：`Core/Recall/EchoStore.cs`

### 3) Recall 管線切到 RecipeId
- `RecallPlan`：`ActionSequence` → **`RecipeId`**（僅帶配方 ID 與 APCost）。
- `CombatPipeline`（Commit）：`RecipeId → BuildFromRecipe → echoStore.TryAdd`；成功才 `MarkRecallUsed()`；**不寫入 Memory**。
- `EchoIntent`：移除 `SlotIndex`，以 `Echo.Id` 做識別。  
**檔案**：`Core/InterOp/InterOps.cs`、`Core/InterOp/Translator.cs`、`Core/Kernel/CombatPipeline.cs`

### 4) RecipeRegistry 上線（最小集）
- 提供：`TryGetRecipe/GetRecipe/ContainsRecipe`。
- 內建樣例：`Attack(1)/Block(2)/Charge(3)/…`，含 `Op/TargetType/CostAP/Name/Label/Summary`。  
**檔案**：`Core/Recall/RecipeRegistry.cs`

### 5) UI / Debug 對齊
- Debug 兩張 Echo（Attack/Block）以 `Id=0` 建立，入庫時自動配號。
- EchoPanel/RecallPanel log 顯示 `slot` 與 **配號後的 `Id`**，驗證「同槽不同 Echo → 不同 Id」。

---

## 🧪 實機驗證重點（節錄）
- 同一槽位先後放入 `Block (ID 2)`、`Attack (ID 3)` → **ID 不重用**。
- Recall 只記 `RecipeId`：`Player recalled RecipeId[1]` → Commit 成功後才見到新 Echo（ID 指派完成）。  
- 播放 Echo：扣 1 AP、造成正確效果；移除以 `Id` 精準，UI 更新正常。

---

## 📦 Diff 統計（0908）
- 9 files changed, 144 insertions(+), 71 deletions(-)

**主要檔案**
- `Combat.cs`（debug 生成 Echo 之 Id=0 占位）
- `Core/InterOp/InterOps.cs`（RecallPlan 改為 RecipeId）
- `Core/InterOp/Translator.cs`（新增 `ContainsRecipe` 驗證與日誌）
- `Core/Kernel/CombatPipeline.cs`（Commit：BuildFromRecipe → TryAdd）
- `Core/Recall/Echo.cs`（Echo 結構與屬性調整）
- `Core/Recall/EchoStore.cs`（內配號 `_nextId` 與重配保險）
- `Core/Recall/RecipeRegistry.cs`（新）
- `Core/UI/RecallQuery.cs`、`UIScript/EchoPanel.cs`（UI 對齊）

---

## 🎯 影響與理由
- **可靠性**：以 `Id` 為唯一錨，消除 UI/核心索引漂移風險。
- **可維護性**：Echo 行為由資料表驅動（RecipeRegistry），測試更聚焦。
- **簡化呼叫端**：Recall 僅傳 `RecipeId`；Factory/Store 各司其職。

---

## 🔍 待辦（輕量）
- Combat 開始時重置 `_nextId`；如有載入/存檔將 `_nextId` 一併持久化。
- `ResolveRecipeId(pattern, config)`：替換 `RecallQuery` 的暫定 `recipeId=1`。
- 單測最小集：
  - `BuildFromRecipe_IdZero_UntilStored`
  - `EchoStore_TryAdd_AssignsIncrementalId_Unique`
  - `EchoStore_TryAdd_ReassignsOnCollision_ForNonZeroId`
  - `Pipeline_Recall_AddsEcho_And_MarksUsed`

---

## 🗒️ 備忘
- Debug Replay **不需要**還原 Echo.Id；只要記錄 `RecipeId`（與播放當下的 `slotIndex` 或 `(recipeId, nth)`）即可重現。

