🛠️ Dev Log — 2025-09-20

範圍：Core + Pipeline + Translator + Godot UI
統計：7 files changed, 200 insertions, 108 deletions

TL;DR

多敵人基礎完成：Actor.Id、CombatState.GetAllEnemies()、TryGetActorById、UI 綁定兩個 EnemyView，意圖更新/清除改為依 enemyId 分發。

Pipeline 安全性：敵方隊列在執行前略過死亡敵人，並僅清空被處理之敵人的意圖。

Translator 目標檢查：TargetType.Target 僅接受存活且非自身的目標，避免點死體。

戰鬥結束條件：玩家死亡或所有敵人都死亡即結束（不再只看單一 Enemy）。

檔案結構清理：Intent 與 RecallView 從 Translator.cs 移到 Utils.cs，降低耦合。

變更重點（依模組）
Godot / UI

Combat.cs

新增 EnemyView2 匯出與 _enemyViews: Dictionary<int, EnemyView> 映射。

BindActorsToUI() 支援兩個敵人；InitializeEnemyViews() 建立 ActorId → View 對表。

UpdateEnemyIntent(enemyId, items) / ClearEnemyIntent(enemyId) 依映射更新/清除對應敵人的 UI。

RefreshAllUI() 會刷新 EnemyView2。

結果：多敵人時，意圖圖示與文字能各自更新、各自清空。

Core / Actor & State

Actor.cs

新增 Id 欄位（預設 -1）；維持既有元件（HP/Shield/AP/Copy）。

CombatState.cs

改為內部管理 _enemies: List<Actor> 與 _actorById: Dictionary<int, Actor>。

內設示例：enemy1.Id=1、enemy2.Id=2；提供 GetAllEnemies() 與 TryGetActorById()。

Enemy 屬性向後相容（回傳第一個敵人，若不存在則擲例外）。

InterOp / Translator & Utils

Translator.cs

移除 Intent/RecallView 型別宣告（下移到 Utils.cs）。

目標解析：TargetType.Target 需 tryGetActor(...) && !ReferenceEquals(actor,self) && actor.IsAlive 才成立。

Utils.cs

新增（或整併）：

public abstract record Intent(int? TargetId)

public sealed record RecallIntent(int RecipeId) : Intent(null)

public sealed record ActIntent(Act Act, int? TargetId) : Intent(TargetId)

public readonly struct RecallView(...)（原來從 Translator 拆出）

命名空間對齊：供 Translator/Pipeline 共用。

Kernel / Pipeline & Phase

CombatPipeline.cs

ProcessEnemyMarkQueue() / ProcessEnemyActionQueue()：

跳過死亡敵人的排程。

蒐集本批有執行的 enemyId → 逐一呼叫 SignalHub.NotifyEnemyIntentCleared(enemyId)（不再硬寫 1）。

GenerateAndEnqueueEnemyActions()（簡易 AI 範例）：

Enemy1（Id=1）：奇數回合宣告 Block（Instant/Mark）；偶數回合宣告 Attack（Delayed）。

Enemy2（Id=2）：每回合宣告 Block（Instant/Mark）。

宣告時即以 SignalHub.NotifyEnemyIntentUpdated(enemy.Id, items) 發送 UI 預告。

CreateEnemyBasicAct(HLAop op)：移除 PushMemory；（與 Canon 一致：敵行為不寫入玩家記憶）

PhaseFunction.cs

CheckCombatEnd(...)：玩家死亡或所有敵方皆死亡 → CombatEnd。

行為驗收（手動）

兩敵 UI：回合開始可見 Enemy1：🛡Block / Enemy2：🛡Defend；下回合切換時，各自的意圖會覆蓋或清空，視佇列執行情況而定。

死體處理：擊殺任一敵人後，其後續回合不再執行佇列，且該敵意圖會被清空，不影響另一名敵人。

目標合法性：嘗試對死亡敵人下達 Target 行為 → Translator 阻擋（BadTarget 類），不會產生命令。

與 Canon 對齊

Only Basic 推入記憶：敵方 Act 取消 PushMemory，符合《GAMEPLAY_CANON.md》。

敵人不使用 AP：本次改動未引入敵方 AP；依舊僅玩家有 AP。

即時/延遲：範例策略維持 B/C → Instant、A → Delayed 的預設節奏。

待辦 / 風險

UI 綁定數量：目前樣例僅兩個 EnemyView；建議後續改為動態容器（依 GetAllEnemies() 自動生成槽位）。

Id 一致性：需在戰鬥初始化階段統一配置 Actor.Id（未來若有載入/存檔，請同步持久化）。

Target 選擇器：玩家側 UI 仍假定單一敵人；後續需提供明確選擇目標的交互。

單元測試：新增

Pipeline_SkipDeadEnemyIntents_And_ClearById

Translator_TargetTypeTarget_RejectsDeadOrSelf

Phase_EndWhenAllEnemiesDead

資料驅動 AI：目前為硬編排示例；建議改為資料表/策略函式便於擴充。

變更檔案

recall_GODOT/Combat.cs（多敵 UI 綁定、意圖分發與清理）

recall_GODOT/Core/ActorOp/Actor.cs（新增 Id）

recall_GODOT/Core/CombatState.cs（多敵清單與 TryGetActorById）

recall_GODOT/Core/InterOp/Translator.cs（目標檢查強化、型別精簡）

recall_GODOT/Core/InterOp/Utils.cs（Intent/RecallView 移入）

recall_GODOT/Core/Kernel/CombatPipeline.cs（隊列處理健全化、AI 範例、逐敵清理意圖）

recall_GODOT/Core/Kernel/PhaseFunction.cs（戰鬥結束條件改為「全滅」）